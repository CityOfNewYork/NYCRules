<?php

/**
 * @file
 * Subscriptions to content events
 *
 * Subscriptions_content extends the Subscriptions module to allow users to
 * subscribe by content type. If a user subscribes to a content he will receive
 * notifications each time a node is published.
 * Subscriptions_content also provides the ability to subscribe to comments and
 * updates of nodes by content type or by other kinds of subscriptions (defined
 * by other Subscriptions submodules).
 */

/**
 * Implements hook_subscriptions().
 *
 * @ingroup hooks
 */
function subscriptions_content_subscriptions($op, $arg0 = NULL, $arg1 = NULL, $arg2 = NULL) {
  static $stypes = array(
    'node' => array('node', 'nid'),
    'type' => array('node', 'type'),
  );
  $function = '_subscriptions_content_' . $op;
  if (function_exists($function)) {
    return $function($arg0, $arg1, $arg2);
  }
  switch ($op) {
    case 'queue':
      // $arg0 is $event array.
      if ($arg0['module'] == 'node') {
        $node = $arg0['node'];
        $params['node']['nid']['value'] = $node->nid;
        $params['node']['type']['value'] = $node->type;
        if ($arg0['type'] == 'comment') {
          $where[] = array('s.send_comments', 1, '=');
        }
        elseif ($arg0['type'] == 'node' && $arg0['action'] == 'update') {
          $where[] = array('s.send_updates', 1, '=');
        }
        if (isset($where)) {
          $params['node']['nid']['where'] = $where;
          $params['node']['type']['where'] = $where;
        }
        return $params;
      }
      break;
    case 'fields': // Parameter is module
      if ($arg0 == 'node' || $arg0 == 'comment') {
        return array(
          'nid' => array(
            'mailvars_function' => '_subscriptions_content_node_mailvars',
            'mailkey' => 'subscriptions_content_node-nid',
            '!subs_type' => t('thread'),
          ),
          'type' => array(
            'mailvars_function' => '_subscriptions_content_node_mailvars',
            'mailkey' => 'subscriptions_content_node-type',
            '!subs_type' => t('content type'),
          ),
        );
      }
      break;
    case 'stypes':
      return $stypes;
    case 'stype':
      return (isset($stypes[$arg0]) ? array_merge( $stypes[$arg0], array($arg1, $arg2)) : NULL);
  }
}

/**
 * Implementation of hook_node_options(), subhook of hook_subscriptions().
 *
 * This is called by subscriptions_ui_node_form() in subscriptions_ui.module.
 *
 * @ingroup form
 * @ingroup hooks
 *
 * @see subscriptions_ui_node_form()
 */
function _subscriptions_content_node_options($account, $node) {
  // Default node, field are the first three indexes, but they can be overridden in params
  // Thread
  $options = array();
  $statics = variable_get('subscriptions_static_content_types', array());
  if (!in_array($node->type, $statics)) {
    $options['nid'][] = array(
      'name' => t('Subscribe to this page'),
      'params' => array('module' => 'node', 'field' => 'nid', 'value' => $node->nid),
      'link' => 'node/' . $node->nid,
    );
    $options['nid']['weight'] = -4;
  }
  $unlisteds = variable_get('subscriptions_unlisted_content_types', array());
  if (user_access('subscribe to content types', $account)) {
    $unlisted_tag = '';
    if (in_array($node->type, $unlisteds)) {
      if (user_access('subscribe to all content types', $account)) {
        $unlisted_tag = '&nbsp;' . SUBSCRIPTIONS_UNAVAILABLE;
      }
      else {
        return $options;
      }
    }
    // Content type
    $type_name = check_plain(node_type_get_name($node->type));
    if ($type_name) {
      $options['type'][] = array(
        'name' => t('To %type content', array('%type' => $type_name)) . $unlisted_tag,
        'params' => array('module' => 'node', 'field' => 'type', 'value' => $node->type),
        'link' => 'type/' . $node->type,
      );
      // Content type and author
      $options['type'][] = array(
        'name' => t('To %type content by %name', array('%type' => $type_name, '%name' => ($node->uid ? check_plain($node->name) : variable_get('anonymous', '???')))) . $unlisted_tag,
        'params' => array('module' => 'node', 'field' => 'type', 'value' => $node->type, 'author_uid' => $node->uid),
        'link' => 'type/' . $node->type . '/' . $node->uid,
      );
      $options['type']['weight'] = -2;
    }
  }
  return $options;
}

/**
 * Implementation of hook_access(), subhook of hook_subscriptions().
 *
 * @ingroup hooks
 */
function _subscriptions_content_access($load_function, $load_args, $node) {
  ///global $user;  /// keep this for remote debugging
  if (($load_function == 'subscriptions_content_load_node' || ($load_function == 'subscriptions_content_load_comment' && $node->_subscriptions_comments)) &&
    ($node->status || user_access('administer nodes')) && node_access('view', $node)) {
    if (!empty($node->type) && subscriptions_content_type_is_blocked($node->type) && !user_access('subscribe to all content types')) {
      return FALSE;
    }
    // We vote 'yes'. Other modules might vote 'no' and then that wins.
    ///watchdog('subs debug', "_sca returns TRUE for node $node->nid, user $user->uid.");  ///
    return TRUE;
  }
  ///watchdog('subs debug', "_sca: node_access('view', $node->nid) returns ". node_access('view', $node) ." for user $user->uid.");  ///
}

/**
 * Implements _hook_types(), subhook of hook_subscriptions().
 *
 * This is called by subscriptions_types() in subscriptions.module.
 *
 * @return
 *   Returns information about types for Subscriptions module interface.
 *
 * @ingroup form
 * @ingroup hooks
 *
 * @see subscriptions_types()
 */
function _subscriptions_content_types() {
  $tr = 't';
  $types['all_types'] = array(
    'title' => '',
    'access' => 'subscribe to all content types',
    'permission' => array(
      'title' => t('Subscribe to all content types'),
      'description' => t('Make unlisted and blocked content types available for subscribing. This is typically used only for administrative roles.'),
    ),
  );
  $types['type'] = array(
    'title' => 'Content types',
    'access' => 'subscribe to content types',
    'permission' => array(
      'title' => t('Subscribe to content types'),
    ),
    'page' => 'subscriptions_content_page_type',
    'fields' => array('node', 'type'),
    'weight' => -20,
  );
  $types['node'] = array(
    'title' => 'Pages/Threads',
    'access' => 'subscribe to content',
    'permission' => array(
      'title' => t('Subscribe to content'),
      'description' => t('Allow the role holder to subscribe to single pages/threads.'),
    ),
    'page' => 'subscriptions_content_page_node',
    'fields' => array('node', 'nid'),
    'weight' => -40,
  );
  return $types;
}

/**
 * Implements hook_node_load().
 *
 * Catch node inserts and updates and send them to the subscriptions queue;
 * catch node deletes and remove any associated thread subscriptions.
 */
function subscriptions_content_node_load($nodes, $types) {
  global $user;
  $unpublished_nids = &drupal_static('subscriptions_content_unpublished_nids', array());
  foreach ($nodes as $node) {
    if (!$node->status) {
      $unpublished_nids[] = $node->nid;
    }
    subscriptions_content_node_prepare($node);
  }
}

/**
 * Implements hook_node_prepare().
 */
function subscriptions_content_node_prepare($node) {
  $node->subscriptions_notify = in_array((isset($node->nid) ? ($node->status ? 'n_pub' : 'n_unpub') : 'n_new'), subscriptions_content_get_default_workflow($node->type));
}

/**
 * Implements hook_node_update().
 */
function subscriptions_content_node_update($node) {
  $unpublished_nids = &drupal_static('subscriptions_content_unpublished_nids', array());
  $inserted = FALSE;
  if (array_search($node->nid, $unpublished_nids) !== FALSE && $node->status) {
    // An unpublished node just became published -- treat this as an 'insert'!
    $inserted = TRUE;
  }
  subscriptions_content_node_insert($node, $inserted);
}

/**
 * Implements hook_node_insert().
 */
function subscriptions_content_node_insert($node, $inserted = TRUE) {
  $event = array(
    'module' => 'node',
    'uid' => $node->uid,
    'load_function' => 'subscriptions_content_load_node',
    'load_args' => $node->nid,
    'type' => 'node',
    'action' => ($inserted ? 'insert' : 'update'),
    'is_new' => $inserted,
    'node' => $node,
  );

  if ($node->uid > 0) {
    _subscriptions_content_autosubscribe($node->type, 'node', 'nid', $node->nid, ($inserted ? 'on_post' : 'on_update'));
  }

  if ((!isset($node->subscriptions_notify) || $node->subscriptions_notify) && !subscriptions_content_suppress_notifications()) {
    subscriptions_queue($event);
  }
}

/**
 * Implements hook_node_delete().
 *
 * Catch node deletes and remove any associated thread subscriptions.
 */
function subscriptions_content_node_delete($node) {
  db_delete('subscriptions')
    ->condition('module', 'node')
    ->condition('field', 'nid')
    ->condition('value', $node->nid)
    ->execute();
}

/**
 * Implements hook_comment_insert().
 *
 * Catch comment inserts and send them to the subscriptions queue.
 */
function subscriptions_content_comment_insert($comment) {
  $node = node_load($comment->nid);
  if (!isset($comment->subscriptions_notify) || $comment->subscriptions_notify) {
    $event = array(
      'module' => 'node',
      'load_function' => 'subscriptions_content_load_comment',
      'load_args' => $comment->cid,
      'uid' => $comment->uid,
      'type' => 'comment',
      'action' => 'insert',
      'is_new' => TRUE,
      'node' => $node,
      'comment' => $comment,
    );
    subscriptions_queue($event);
  }
  _subscriptions_content_autosubscribe($node->type, 'node', 'nid', $comment->nid, 'on_comment');
}

/**
 * Implements hook_comment_update().
 *
 * Catch comment updates and send them to the subscriptions queue.
 */
function subscriptions_content_comment_update($comment) {
  $node = node_load($comment->nid);
  if (!isset($comment->subscriptions_notify) || $comment->subscriptions_notify) {
    $event = array(
      'module' => 'node',
      'load_function' => 'subscriptions_content_load_comment',
      'load_args' => $comment->cid,
      'uid' => $comment->uid,
      'type' => 'comment',
      'action' => 'update',
      'is_new' => $comment->status == COMMENT_PUBLISHED && $comment->original->status != COMMENT_PUBLISHED,
      'node' => $node,
      'comment' => $comment,
    );
    subscriptions_queue($event);
  }
  _subscriptions_content_autosubscribe($node->type, 'node', 'nid', $comment->nid, 'on_comment');
}

/**
 * Implements hook_form_alter().
 *
 * Add the Content Settings part to admin/settings/subscriptions,
 *
 * @ingroup hooks
 * @ingroup form
 */
function subscriptions_content_form_subscriptions_settings_form_alter(&$form, &$form_state) {
  $tr = 't';

  // General content settings
  $select = array();
  $select[0] = '<' . t('none') . '>';
  $nodetypes = node_type_get_types();
  foreach ($nodetypes as $ntype => $nname) {
    $select[$ntype] = $nname->name;
  }
  $form['content'] = array(
    '#type' => 'fieldset',
    '#title' => t('Content settings'),
    '#collapsible' => TRUE,
    '#weight' => -10,
  );
  $form['content']['subscriptions_unlisted_content_types'] = array(
    '#type'          => 'select',
    '#title'         => t('Unlisted content types'),
    '#default_value' => variable_get('subscriptions_unlisted_content_types', array()),
    '#options'       => $select,
    '#description'   => t('Select content types which should be <strong>removed from subscription listings</strong>.<br />The content may still be available for subscribing via different kinds of subscriptions, but subscribing by content type will be unavailable for the selected types.'),
    '#multiple'      => TRUE,
  );
  $form['content']['subscriptions_blocked_content_types'] = array(
    '#type'          => 'select',
    '#title'         => t('Blocked content types'),
    '#default_value' => variable_get('subscriptions_blocked_content_types', array()),
    '#options'       => $select,
    '#description'   => t('Select content types which should be <strong>completely unavailable for subscribing</strong>, i.e. content of the selected types will never trigger notifications for regular users.'),
    '#multiple'      => TRUE,
  );
  $form['content']['subscriptions_blocked_content_types_note'] = array(
    '#type'          => 'item',
    '#title'         => t('Note'),
    '#markup'        => t("The %permission permission grants normal access to unlisted and blocked content types; this is intended as an administrative function, and the content types and links will be marked with a '!symbol' symbol (and appear !red_ON like this !red_OFF in the case of blocked types).", array('%permission' => t('subscribe to all content types'), '!symbol' => SUBSCRIPTIONS_UNAVAILABLE, '!red_ON' => '<span class="error">', '!red_OFF' => '</span>')),
  );
  $form['content']['subscriptions_blocked_nodes'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Blocked nodes'),
    '#size'          => 100,
    '#maxlength'     => 1000,
    '#default_value' => variable_get('subscriptions_blocked_nodes', ''),
    '#description'   => t('Enter the IDs of nodes that should be <strong>completely unavailable for subscribing</strong>, separated by spaces.'),
  );
  $form['#validate'][] = '_subscriptions_content_validate_blocked_nodes';

  $statics = variable_get('subscriptions_static_content_types', array());
  $avoid_empty_subscribe_links = variable_get('subscriptions_avoid_empty_subscribe_links', 0);
  $form['content']['static_content'] = array(
    '#type' => 'fieldset',
    '#title' => t('Static content'),
    '#collapsible' => TRUE,
    '#collapsed' => (empty($statics) || (count($statics) == 1 && isset($statics[0]))) && !$avoid_empty_subscribe_links,
  );
  $form['content']['static_content']['subscriptions_static_content_types'] = array(
    '#type'          => 'select',
    '#title'         => t('Static content types'),
    '#default_value' => $statics,
    '#options'       => $select,
    '#description'   => t('Select content types which do not change nor receive comments and thus should not have the %option option.', array('%option' => t('Subscribe to this page'))),
    '#multiple'      => TRUE,
  );
  $form['content']['static_content']['subscriptions_avoid_empty_subscribe_links'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Avoid empty %Subscribe links', array('%Subscribe' => t('Subscribe'))),
    '#default_value' => $avoid_empty_subscribe_links,
    '#description'   => t('Nodes of %Static_content_types may end up with no %Subscribe options at all. Turn this option on to avoid displaying %Subscribe links in this case. The default is OFF, because this option causes processing overhead for each node view operation.', array('%Static_content_types' => t('Static content types'), '%Subscribe' => t('Subscribe'))),
  );

  $form['content']['subscriptions_generate_full_node'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Generate the %full_node variable', array('%full_node' => '!full_node')),
    '#default_value' => variable_get('subscriptions_generate_full_node', 0),
    '#description'   => t("Generating this variable causes considerable overhead even if it's not used, and <strong>it may even cause errors</strong>, depending on the !content_type! Default is OFF.", array('!content_type' => $tr('content type'))),
  );
}

/**
 * Validate the 'subscriptions_blocked_nodes' input.
 */
function _subscriptions_content_validate_blocked_nodes($form, $form_state) {
  $form_values = $form_state['values'];
  $values = $form_values['subscriptions_blocked_nodes'];
  if (!empty($values)) {
    $values = explode(' ', $values);
    foreach ($values as $v) {
      if (!empty($v) && !is_numeric($v)) {
        form_set_error('subscriptions_blocked_nodes', t('Enter a series of numbers, separated by spaces.'));
        break;
      }
    }
  }
}

/**
 * Implements hook_form_alter().
 *
 * Add the 'Send subscriptions notifications' to the Workflow settings on
 * admin/content/types/CONTENT_TYPE,
 *
 * @ingroup hooks
 * @ingroup form
 */
function subscriptions_content_form_node_type_form_alter(&$form, &$form_state) {
  $tr = 't';
  $form['workflow']['subscriptions_workflow'] = array(
    '#type' => 'select',
    '#title' => t('Default %Send_subscriptions_notifications options for', array('%Send_subscriptions_notifications' => t('Send subscriptions notifications'))),
    '#default_value' => subscriptions_content_get_default_workflow($form['#node_type']->type),
    '#options' => array(
      'n_new' => t('New nodes'),
      'n_unpub' => t('Unpublished nodes (as new)'),
      'n_pub' => t('Published nodes (as update)'),
      'c_new' => t('New comments'),
      'c_unpub' => t('Unpublished comments (as new)'),
      'c_pub' => t('Published comments (as update)'),
    ),
    '#multiple' => TRUE,
    '#description' => t('Select all situations where generation of notifications should be ON.') . '<br />' .
      t('Items that are created in unpublished state create notifications to administrators only; when they are later published, "new" notifications are generated.') . '<br />' .
      t('Users with the %administer_nodes / %administer_comments permissions will be able to override these options.', array(
        '%administer_nodes' => $tr('administer nodes'),
        '%administer_comments' => $tr('administer comments'),
      )),
  );
  $form['#submit'][] = 'subscriptions_content_node_type_form_submit';
}

function subscriptions_content_get_default_workflow($content_type) {
  return variable_get('subscriptions_default_workflow_' . $content_type, array('n_new', 'n_unpub', 'n_pub', 'c_new', 'c_unpub', 'c_pub'));
}

function subscriptions_content_node_type_form_submit($form, &$form_state) {
  variable_set('subscriptions_default_workflow_' . $form_state['values']['type'], $form_state['values']['subscriptions_workflow']);
}

/**
 * Implements hook_form_alter().
 *
 * Add the Send Subscriptions Notifications checkbox to the Publishing Options
 * fieldset on the node edit form.
 *
 * @ingroup hooks
 * @ingroup form
 */
function subscriptions_content_form_alter(&$form, &$form_state, $form_id) {
  global $user;

  if (isset($form['type']['#value']) && $form['type']['#value'] . '_node_form' == $form_id) {
    if (isset($form['options'])) {
      $tr = 't';
      $form['options']['subscriptions_notify'] = array(
        '#weight' => 50,
      );
      $form['options']['subscriptions_notify']['subscriptions_notify'] = array(
        '#type' => 'checkbox',
        '#title' => t('Send subscriptions notifications'),
        '#default_value' => (isset($form['#node']->subscriptions_notify) ? $form['#node']->subscriptions_notify : TRUE),
        '#attributes' => array('class' => array('subscriptions-notifications')),
      );
      $form['options']['subscriptions_notify']['note'] = array(
        '#type' => 'item',
        '#description' => t('You may want to turn %Send_subscriptions_notifications OFF when you only change %Publishing_options, otherwise Subscriptions will send out "update" notifications &mdash; this option is not saved.<br />Subscriptions does not send notifications for unpublished nodes (except to users who have the %administer_nodes permission), but when you set %Published to ON, Subscriptions will send out "new" notifications, unless you turn this off here.',
                            array('%Send_subscriptions_notifications' => t('Send subscriptions notifications'),
                                  '%Publishing_options' => $tr('Publishing options'),
                                  '%administer_nodes' => $tr('Administer content'),
                                  '%Published' => $tr('Published'))),
      );
    }
  }
}

/**
 * Implements hook_form_alter().
 *
 * Add submit handler to catch bulk content operations and suppress
 * notifications by default.
 *
 * @ingroup hooks
 * @ingroup form
 */
function subscriptions_content_form_node_admin_content_alter(&$form, &$form_state) {
  $form['admin']['options']['subscriptions_notify'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send subscriptions notifications'),
    '#description' => '<br />' . t('When publishing unpublished nodes, you probably want to turn this ON.'),
    '#prefix' => '<br />',
  );
  array_unshift($form['admin']['options']['submit']['#submit'], 'subscriptions_content_node_admin_nodes_submit');
}

/**
 * Implements hook_form_alter().
 *
 * Add submit handler to catch bulk content moderation submissions.
 *
 * @ingroup hooks
 * @ingroup form
 */
function subscriptions_content_form_node_admin_nodes_alter(&$form, &$form_state) {
  array_unshift($form['#submit'], 'subscriptions_content_node_admin_nodes_submit');
}

/**
 * Implements hook_form_alter().
 *
 * Add the Send Subscriptions Notifications checkbox to the Administration Options
 * fieldset on the comment edit form.
 *
 * @ingroup hooks
 * @ingroup form
 */
function subscriptions_content_form_comment_form_alter(&$form, &$form_state) {
  $is_update = isset($form['cid']['#value']);
  $is_unpublished = ($is_update ? $form['author']['status']['#default_value'] : !user_access('post comments without approval'));
  if (user_access('administer comments')) {
    $tr = 't';
    // create the Administration fieldset if it doesn't exist:
    //if (!isset($form['author'])) {
    //  $form['author'] = array(
    //    '#type' => 'fieldset',
    //    '#title' => $tr('Administration'),
    //    '#collapsible' => TRUE,
    //    '#collapsed' => TRUE,
    //    '#weight' => -2,
    //  );
    //}
    $item =& $form['author']['subscriptions_notify'];
    $item['#type'] = 'item';
    $item['subscriptions_notify'] = array(
      '#type' => 'checkbox',
      '#title' => t('Send subscriptions notifications'),
    );

    $node = node_load($form['nid']['#value']);
    $default_workflow = subscriptions_content_get_default_workflow($node->type);
    if ($is_update && $is_unpublished) {
      $item['#description'] = t('Subscriptions notifications are not sent for unpublished comments (except to users who have the %administer_comments permission), but when you change !Status to %Published, Subscriptions will send out "new" notifications, unless you suppress this here. ', array(
        '%administer_comments' => $tr('administer comments'),
        '!Status' => $tr('Status'),
        '%Published' => $tr('Published'),
      ));
      $item['subscriptions_notify']['#default_value'] = in_array('c_unpub', $default_workflow);
    }
    elseif ($is_unpublished) {
      $item['#description'] = t('Subscriptions notifications are not sent for unpublished comments, except to users who have the %administer_comments permission, and you can even suppress the latter here.', array(
        '%administer_comments' => $tr('administer comments'),
      ));
      $item['subscriptions_notify']['#default_value'] = in_array('c_new', $default_workflow);
    }
    else { // published, new or update
      $item['#description'] = t('You can suppress sending subscriptions notifications here; this option is not saved.');
      $item['subscriptions_notify']['#default_value'] = in_array(($is_update ? 'c_pub' : 'c_new'), $default_workflow);
    }
  }
}

/**
 * Handle bulk publishing.
 */
function subscriptions_content_node_admin_nodes_submit($form, &$form_state) {
  if (!$form_state['values']['subscriptions_notify']) {
//dpm("SUPPRESS");
    subscriptions_content_suppress_notifications(TRUE);
    return;
  }
//dpm("ALLOW");
  if ($form_state['values']['operation'] == 'publish') {
    foreach ($form_state['values']['nodes'] as $nid) {
      if ($nid != 0 && ($node = node_load($nid)) && !$node->status) {
        subscriptions_content_nodeapi($node, 'prepare');
        subscriptions_content_nodeapi($node, 'update', TRUE);  // (avoid autosubscribe)
      }
    }
  }
}

/**
 * Provide a static flag to suppress notifications.
 */
function subscriptions_content_suppress_notifications($set = NULL) {
  static $suppress_notifications = FALSE; // not drupal_static!
  if ($set !== NULL) {
    $suppress_notifications = $set;
  }
  return $suppress_notifications;
}

/**
 * Auto-subscribe, if the content type is not blocked.
 *
 * @param $content_type
 *   Content type of the node to subscribe to.
 * @param $module
 *   Parameter for subscriptions_autosubscribe().
 * @param $field
 *   Parameter for subscriptions_autosubscribe().
 * @param $value
 *   Parameter for subscriptions_autosubscribe().
 * @param $context
 *   Parameter for subscriptions_autosubscribe().
 */
function _subscriptions_content_autosubscribe($content_type, $module, $field, $value, $context) {
  if (subscriptions_content_type_is_blocked($content_type)) {
    return;
  }
  subscriptions_autosubscribe($module, $field, $value, $context);
}

/**
 * Return TRUE if the content type is blocked.
 *
 * @param $content_type
 */
function subscriptions_content_type_is_blocked($content_type) {
  $blockeds = variable_get('subscriptions_blocked_content_types', array());
  return in_array($content_type, $blockeds);
}

/**
 * Fill given array of mailvars with given node values.
 *
 * Callback of function _subscriptions_content_node_mailvars().
 *
 * @param $mailvars
 *   Array of mailvars to be full-filled.
 * @param $node
 *   Node object used to fill $mailvars.
 * @param $field
 *   Internal use for filling variable !term_name.
 * @param $s
 *   Subscription object.
 */
function _subscriptions_content_node_mailvars(&$mailvars, $node, $field, $s) {
  global $language;
  include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'subscriptions_mail') . '/subscriptions_mail.templates.inc';
  include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'subscriptions') . '/subscriptions.mail.inc';

  //$langcode = $GLOBALS['language_content']->language;
  $node = (is_array($node) ? (object) $node : $node);
  $langcode = $node->language;
  $body = $node->body[$langcode][0];
  $format = $body['format'];
//dpm($format);
  $body = field_view_field('node', $node, 'body', 'full', $langcode);
  $body = $body[0]['#markup'];
  $teaser = field_view_field('node', $node, 'body', 'teaser', $langcode);
//dpm($teaser);
  $teaser = $teaser[0]['#markup'];
  $mailvars['!url'] = url('node/' . $node->nid, array('absolute' => TRUE));
  $mailvars['!node_type'] = $node->type;
  $mailvars['!title'] = trim($node->title);
  $mailvars['!teaser'] = subscriptions_html_to_text($teaser);
//dpm($mailvars['!teaser']);
  $mailvars['!body'] = subscriptions_html_to_text($body);
  $mailvars['!nid'] = $node->nid;
  $mailvars['!full_node'] = (variable_get('subscriptions_generate_full_node', 0) ? _subscriptions_content_format_text(node_view($node, FALSE, TRUE, FALSE)) : '!full_node');
  $mailvars['!is_new'] = (integer) !empty($node->_subscriptions_is_new);
  $mailvars['!is_updated'] = (integer) !empty($node->_subscriptions_is_updated);
  $mailvars['!is_old'] = (integer) (empty($node->_subscriptions_is_new) && empty($node->_subscriptions_is_updated));
  $mailvars['!is_published'] = $node->status;
  $mailvars['!has_new_comments'] = (integer) !empty($node->_subscriptions_comments);
  if ($field == 'tid') {
    $mailvars['!term_name'] = db_query('SELECT name FROM {taxonomy_term_data} WHERE tid = :tid', array(':tid' => $s['value']))->fetchField();
  }
  elseif (!empty($node->tid)) {
    $mailvars['!term_name'] = db_query('SELECT name FROM {taxonomy_term_data} WHERE tid = :tid', array(':tid' => $node->tid))->fetchField();
  }
  else {
    unset($mailvars['!term_name']);
  }
  if ($s['load_function'] == 'subscriptions_content_load_comment' || ($s['load_function'] == 'subscriptions_content_load_node' && isset($node->_subscriptions_comments))) {
    $comment_template = subscriptions_mail_template_load(SUBSCRIPTIONS_COMMENT_MAILKEY, $language->language, 'body', 'CITEM');
    $separator = subscriptions_mail_template_load(SUBSCRIPTIONS_COMMENT_MAILKEY, $language->language, 'subject', 'SEP');
    $mailvars['!comments'] = _subscriptions_content_format_comments($node, $comment_template, $separator);
  }
  else {
    $mailvars['!comments'] = '';
  }
  $files = '';
  if (isset($node->files) && user_access('view uploaded files')) {
    foreach ($node->files as $file) {
      $files .= file_create_url($file->filepath) . "\n";
    }
  }
  $mailvars['!has_files'] = empty($files) ? 0 : 1;
  $mailvars['!files'] = $files;

  $account = user_load($node->revision_uid);
  $mailvars['!revision_name'] = $account->name;
  $mailvars['!revision_log'] = _subscriptions_content_format_text($node->log);
}

/**
 * Convert text with formatting into plain text.
 */
function _subscriptions_content_format_text($text, $format = NULL, $langcode = '') {
  static $have_img_assist;
  if (!isset($have_img_assist)) {
    $have_img_assist = module_exists('img_assist');
  }
  if (!empty($have_img_assist)) {
    foreach (img_assist_get_macros($text) as $unexpanded_macro => $macro) {
      $expanded_macro = img_assist_render_image($macro);
      if (preg_match('/<img src="([^"]*)".*title="([^"]*)"/', $expanded_macro, $matches)) {
        $text = str_replace($unexpanded_macro, " [<a href=\"$matches[1]\">$matches[2]</a>] ", $text);
      }
    }
  }

//dpm($text, "_subscriptions_content_format_text IN");
  if (isset($format)) {
    $text = check_markup($text, $format, $langcode, FALSE);
  }
//dpm($text, "AFTER check_markup(\$text, '$format', '$langcode', FALSE)");
  $text = subscriptions_html_to_text($text);
//dpm($text, "AFTER subscriptions_html_to_text(\$text)");
  return trim($text);
}

/**
 * Given a comment template returns a formatted text of comments for given
 * node.
 */
function _subscriptions_content_format_comments($node, $comment_template, $separator) {
  $comments = array();
  foreach (element_children($node->_subscriptions_comments) as $cid) {
    $comment = $node->_subscriptions_comments[$cid]['#comment'];
    $mailvars = array(
      '!comment_name' => ($comment->uid == 0 ? variable_get('anonymous', '!comment_name') : $comment->name),
      '!comment_uid' => $comment->uid,
      '!comment_title' => trim($comment->subject),
      '!comment_text' => $comment->comment_body[$comment->language][0]['safe_value'],
      '!comment_cid' => $comment->cid,
      '!comment_nid' => $comment->nid,
      '!comment_url' => url('node/' . $comment->nid, array('fragment' => 'comment-' . $comment->cid, 'absolute' => TRUE)),
      '!comment_is_new' => (integer) $comment->_subscriptions_is_new,
      '!comment_is_published' => (integer) ($comment->status == COMMENT_PUBLISHED),
    );
    if (function_exists('realname_make_name')) {
      $mailvars += array(
        '!comment_realname' => realname_make_name($comment),
      );
    }

    $template = module_invoke('subscriptions_mail', 'template_preprocess', $comment_template, $mailvars);
    $comments[] = strtr($template ? $template : $comment_template, $mailvars);
  }
  return implode($separator, $comments);
}

/**
 * Custom function for loading nodes.
 * Loads not only the node but also any attached comments that are in the queue.
 *
 * Function name stored in {subscriptions_queue}.load_func and called by
 * subscriptions_mail().
 *
 * @param $nid
 *   Node ID.
 * @param $sqid
 *   Subscriptions queue ID.
 * @param $is_new
 *   TRUE if this is a new-node notification.
 *
 * @return node as array().
 */
function subscriptions_content_load_node($nid, $sqid, $is_new) {
  // Do not cache because for different users the node can be different,
  //  subscriptions_mail_cron caches per uid.
  $node = _subscriptions_content_load($nid, 0);
  if (empty($node)) {
    return;
  }
  if ($is_new) {
    $node->_subscriptions_is_new = TRUE;
  }
  else {
    $node->_subscriptions_is_updated = TRUE;
  }
  return $node;
}

/**
 * Custom function for loading comments.
 *
 * Function name stored in {subscriptions_queue}.load_func and called by
 * subscriptions_mail().
 *
 * @param $cid
 *   Comment ID.
 * @param $sqid
 *   Subscriptions queue ID.
 *
 * @return node as array().
 */
function subscriptions_content_load_comment($cid, $sqid) {
  $nid = db_query('SELECT nid FROM {comment} WHERE cid = :cid', array(':cid' => $cid))->fetchField();
  if (empty($nid)) {
    return;
  }
  $item = db_query('SELECT sq.module, sq.field FROM {subscriptions_queue} sq WHERE sqid = :sqid', array(':sqid' => $sqid))->fetchAssoc();
  if ($item['module'] != 'node' || $item['field'] != 'nid') {
    // Only if we're processing a node/nid queue item should we cut off the comments at an update item, otherwise not:
    $sqid = NULL;
  }
  $node = _subscriptions_content_load($nid, $sqid);
  if (empty($node->_subscriptions_comments)) {
    return;
  }
  return $node;
}

/**
 * Returns a node if published, including any comments that are still queued, but
 * limited by the given subscriptions queue ID.
 */
function _subscriptions_content_load($nid, $comment_load_sqid) {
  global $user;

  $node = node_load($nid, NULL, TRUE);
  // Note: we must not cache across users (access checking), and we take care
  // not to process the same node more than once (except for multiple batches
  // of comments), so we don't gain from caching nodes; on the contrary: we
  // might run out of memory!

  if (!empty($node) && module_exists('comment')) {
    $published_comments_only = $limit_sqids = '';

    // Load comments like comment_get_thread().
    $query = db_select('comment', 'c');
    $query->addField('c', 'cid');
    $query
      ->condition('c.nid', $nid)
      ->addTag('node_access')
      ->addTag('comment_filter')
      ->addMetaData('node', $node);

    $query->join('subscriptions_queue', 'sq', (db_driver() != 'pgsql' ? 'c.cid = sq.load_args' : 'CAST(c.cid AS VARCHAR) = sq.load_args'));
    $query->addField('sq', 'sqid', '_subscriptions_sqid');
    $query->addField('sq', 'is_new', '_subscriptions_is_new');
    $query->condition('sq.uid', $user->uid);
    $query->condition('sq.load_function', 'subscriptions_content_load_comment');

    if (!user_access('administer comments')) {
      $query->condition('c.status', COMMENT_PUBLISHED);
    }
    $query->orderBy('c.cid', 'ASC');

    if (!empty($comment_load_sqid)) {
      // check for a later queued update notification (don't send comments past that one because it will go out as node/type with its own comments later!)
      if ($cutoff_sqid = db_query_range("SELECT sqid FROM {subscriptions_queue} WHERE module = 'node' AND field = 'nid' AND value = :value AND uid = :uid AND load_function = 'subscriptions_content_load_node' AND sqid > :sqid", 0, 1, array(':value' => $nid, ':uid' => $user->uid, ':squid' => $comment_load_sqid))->fetchField()) {
        $query->condition('q.sqid', $cutoff_sqid, '<');
      }
    }

    $sqids = $cids = array();
    foreach ($query->execute() as $comment_info) {
      if ($comment_info && user_access('access comments') && !isset($comment_infos[$comment_info->cid])) {
        $cids[] = $comment_info->cid;
        $comment_infos[$comment_info->cid] = $comment_info;
      }
      $sqids[] = $comment_info->_subscriptions_sqid;
    }
    if ($sqids) {
      db_delete('subscriptions_queue')
        ->condition('sqid', $sqids, 'IN')
        ->execute();
    }

    if ($cids) {
      $comments = comment_load_multiple($cids);
      foreach ($comments as $cid => $comment) {
        $comment->_subscriptions_sqid = $comment_infos[$cid]->_subscriptions_sqid;
        $comment->_subscriptions_is_new = $comment_infos[$cid]->_subscriptions_is_new;
        $comment->in_preview = TRUE;
      }
      $node->_subscriptions_comments = comment_view_multiple($comments, $node);
    }
  }
  return (empty($node) ? NULL : $node);
}

/**
 * Subscriptions page callback: List thread subscriptions.
 */
function subscriptions_content_page_node($account, $form) {
  return drupal_get_form('subscriptions_content_node_form', $account, $form);
}

/**
 * Build the Thread subscriptions form at user/UID/subscriptions/node.
 *
 * @ingroup form
 */
function subscriptions_content_node_form($form, &$form_state, $account, $form) {
  $uid = $account->uid;
  $tr = 't';
  $subscriptions = array();
  $query = db_select('node', 'n', array('fetch' => PDO::FETCH_ASSOC))
    ->extend('PagerDefault')
    ->limit(50);
  $query
    ->fields('n', array('nid', 'uid', 'title', 'status', 'changed'))
    ->join('subscriptions', 's', (db_driver() != 'pgsql' ? 'n.nid = s.value' : 'CAST(n.nid AS VARCHAR) = s.value'));
  $query
    ->fields('s', array('send_interval', 'author_uid', 'send_comments', 'send_updates'));
  if (module_exists('comment')) {
    $query
      ->leftJoin('node_comment_statistics', 'ncs', 'n.nid = ncs.nid');
    $query
      ->fields('ncs', array('last_comment_timestamp'));
    $query->addExpression('IF(s.send_comments + s.send_updates = 0,
                              n.created,
                              IF(s.send_comments + s.send_updates = 2,
                                 IF(n.changed > ncs.last_comment_timestamp,
                                    n.changed,
                                    ncs.last_comment_timestamp),
                                 IF(s.send_comments = 1,
                                    ncs.last_comment_timestamp,
                                    n.changed)))', 'latest_activity');
  }
  else {
    $query->addExpression('IF(s.send_updates = 0, n.created, n.changed)', 'latest_activity');
  }
  $query
    ->condition('s.module', 'node')
    ->condition('s.field', 'nid')
    ->condition('s.recipient_uid', $uid)
    ->orderBy('latest_activity', 'desc')
    ->addTag('node_access');
  foreach ($query->execute() as $s) {
    $subscriptions[$s['nid']][$s['author_uid']] = $s;
  }

  // check whether we've commented:
  $nids = array_keys($subscriptions);
  $select = db_select('subscriptions', 's')
    ->fields('s', array('value'))
    ->condition('s.module', 'node')
    ->condition('s.field', 'nid')
    ->condition('s.recipient_uid', $uid);
  $result = db_select('comment', 'c')
    ->fields('c')
    ->condition('c.nid', $select, 'IN')
    ->condition('c.uid', $uid)
    ->groupBy('c.nid')
    ->execute();
  foreach ($result as $c) {
    if (isset($subscriptions[$c->nid])) {
      foreach ($subscriptions[$c->nid] as $author_uid => $subscription) {
        $subscriptions[$c->nid][$author_uid]['commented'] = TRUE;
      }
    }
  }

  $form[0] = array(
    '#type' => 'item',
    '#title' => '',
    '#tree' => TRUE,
    '#theme' => 'subscriptions_form_table',
  );
  $defaults = array();
  foreach ($subscriptions as $nid => $bundle) {
    foreach ($bundle as $author_uid => $subscription) {
      $title = truncate_utf8($subscription['title'], 40);
      if ($title != $subscription['title']) {
        $title .= '...';
      }
      $title = l($title, 'node/' . $subscription['nid']);
      if (!$subscription['status']) {
        if (user_access('administer nodes')) {
          $title = SUBSCRIPTIONS_UNAVAILABLE . '&nbsp;' . $title;
        }
        else {
          continue;
        }
      }
      $subscription['extra_info'] = t('@latest_activity, @authored, @commented', array(
        '@latest_activity' => format_interval(time() - $subscription['latest_activity']),
        '@authored' => ($subscription['uid'] == $uid ? $tr('Yes') : $tr('No')),
        '@commented' => (!empty($subscription['commented']) ? $tr('Yes') : $tr('No')),
      ));
      subscriptions_form_helper($form[0], $defaults, $author_uid, $subscription['nid'], $title, $subscription);
    }
  }
  unset($form[0]['author']);

  if (count(element_children($form[0]))) {
    $form[0]['extra_info']['#title'] = t('Latest activity, authored, commented');
    $form[0]['defaults'] = array(
      '#type' => 'value',
      '#value' => $defaults,
    );
    subscriptions_form_column_filter($form[0], $uid);
    $form['#tree'] = TRUE;
    $form['uid'] = array('#type' => 'value', '#value' => $uid);
    $form['access_key'] = array('#type' => 'value', '#value' => 'node');
    $form['module'] = array('#type' => 'value', '#value' => 'node');
    $form['field'] = array('#type' => 'value', '#value' => 'nid');
    $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 10);
    $form['#submit'][] = 'subscriptions_page_form_submit';
    $form['note'] = array('#type' => 'item', '#description' => '<div>' . t('Note: Deactivated subscriptions will be removed from the list.') . '</div>' );
    $form['pager'] = array('#value' => theme('pager', array('tags' => NULL, 'element' => 0, 'quantity' => 50)));
  }
  else {
    unset($form['header']);
    unset($form['footer']);
    $form['notice'] = array(
      '#markup' => t('There are no subscribed pages. '),
      '#weight' => 10,
    );
  }
  return $form;
}

/**
 * Subscriptions page callback: List content types subscriptions.
 */
function subscriptions_content_page_type($account, $form) {
  return drupal_get_form('subscriptions_content_type_form', $account, $form);
}

/**
 * Build the Content Types subscriptions form at user/UID/subscriptions/type.
 *
 * @ingroup form
 */
function subscriptions_content_type_form($form, &$form_state, $account, $form) {
  $uid = (isset($account) ? $account->uid : (is_numeric(arg(5)) ? -arg(5) : -DRUPAL_AUTHENTICATED_RID));
  $unlisteds = variable_get('subscriptions_unlisted_content_types', array());
  $blockeds = variable_get('subscriptions_blocked_content_types', array());
  $omits = array_merge($unlisteds, $blockeds);
  $query = db_select('subscriptions', 's', array('fetch' => PDO::FETCH_ASSOC));
  $nt_alias = $query->join('node_type', 'nt', 's.value = nt.type');
  $result = $query
    ->fields('s', array('value', 'send_interval', 'author_uid', 'send_comments', 'send_updates'))
    ->fields($nt_alias, array('type', 'name'))
    ->condition('s.module', 'node')
    ->condition('s.field', 'type')
    ->condition('s.recipient_uid', $uid)
    ->addTag('node_type_access')
    ->orderBy('s.author_uid')
    ->execute();
  foreach ($result as $s) {
    $subscriptions[$s['value']][$s['author_uid']] = $s;
  }
  $form[0] = array(
    '#theme' => 'subscriptions_form_table',
  );
  $intervals = _subscriptions_send_intervals();
  foreach (node_type_get_types() as $type) {
    // add the active subscriptions
    $type_name = check_plain($type->name);
    if (in_array($type->type, $omits)) {
      if (user_access('subscribe to all content types') || user_access('administer site configuration')) {
        if (in_array($type->type, $blockeds)) {
          $type_name = '<span class="error" title="' . t('This !content_type is blocked. ', array('!content_type' => t('content type'))) . '">' . $type_name . '</span>&nbsp;' . SUBSCRIPTIONS_UNAVAILABLE;
        }
        else {
          $type_name = $type_name . '&nbsp;' . SUBSCRIPTIONS_UNAVAILABLE;
        }
      }
      else {
        continue;
      }
    }
    if (!isset($subscriptions[$type->type][-1])) {
      // author-less item is missing -- add it here:
      $subscriptions[$type->type][-1] = array(
        'send_interval' => _subscriptions_get_setting('send_interval', ($uid < 0 ? $uid : $account)),
        'send_comments' => _subscriptions_get_setting('send_comments', ($uid < 0 ? $uid : $account)),
        'send_updates' => _subscriptions_get_setting('send_updates', ($uid < 0 ? $uid : $account)),
        'author_uid' => FALSE,
      );
    }
    foreach ($subscriptions[$type->type] as $author_uid => $subscription) {
      subscriptions_form_helper($form[0], $defaults, $author_uid, $type->type, $type_name, $subscription);
    }
  }

  if (isset($form[0]['checkboxes'])) {
    $form[0]['defaults'] = array(
      '#type' => 'value',
      '#value' => $defaults,
    );
    subscriptions_form_column_filter($form[0], $uid);
    $form['#tree'] = TRUE;
    $form['uid'] = array('#type' => 'value', '#value' => $uid);
    $form['access_key'] = array('#type' => 'value', '#value' => 'type');
    $form['module'] = array('#type' => 'value', '#value' => 'node');
    $form['field'] = array('#type' => 'value', '#value' => 'type');
    $form['submit'] = array('#type' => 'submit', '#value' => t('Save'), '#weight' => 10);
    $form['#submit'][] = 'subscriptions_page_form_submit';
  }
  else {
    $form['header']['#value'] = t('There are no available !subs_types. ', array('!subs_types' => t('content types')));
    unset($form['footer']);
  }
  return $form;
}

/**
 * Implements hook_mailkeys().
 *
 * Provide mailkeys for mail_edit.
 *
 * @ingroup hooks
 */
function subscriptions_content_mailkeys() {
  $mailkeys['node-nid'] = t('Notifications for %Pages (update/comment) subscriptions', array('%Pages' => t('Pages/Threads')));
  foreach (array_keys(node_type_get_types()) as $type) {
    $mailkeys['node-type-' . $type] = t('Notifications for %type !content_type subscriptions', array('%type' => $type, '!content_type' => t('content type')));
  }
  return $mailkeys;
}

/**
 * Implements hook_mail_edit_tokens_list().
 *
 * Provide replacable tokens for mail_edit.
 *
 * @ingroup hooks
 */
function subscriptions_content_mail_edit_tokens_list($mailkey, $options = array()) {
  $tr = 't';
  $tokens = array();
  switch ($mailkey) {
    case 'comments':
      $tokens += array(
        '!comment_name'         => t('The name of the comment author. '),
      );
      if (module_exists('realname')) {
        $tokens += array(
          '!comment_realname'   => t('The real name of the comment author (provided by Realname module).'),
        );
      }
      $tokens += array(
        '!comment_uid'          => t('The ID of the comment author (0 = %anonymous).', array('%anonymous' => variable_get('anonymous', t('Anonymous')))),
        '!comment_title'        => t('The title of the comment.'),
        '!comment_text'         => t('The body text of the comment.'),
        '!comment_cid'          => t('The ID of the comment.'),
        '!comment_nid'          => t("The ID of the comment's node."),
        '!comment_url'          => t('The direct URL of the comment.'),
        '!comment_is_new'       => t('The type of comment notification: 1 = new comment, 0 = updated comment.'),
        '!comment_is_published' => t('The comment publication state: 1 = published, 0 = unpublished.<br />(Unpublished comments are sent to users with the %administer_comments permission only.)', array('%administer_comments' => $tr('administer comments'))),
      );
      return $tokens;

    default:
      $tokens += array(
        '!unsubscribe_url'     => t('The user can unsubscribe by clicking this link.'),
        '!sender_name'         => t('The name of the sender (if the sender is visible).'),
      );
      if (module_exists('realname')) {
        $tokens += array(
          '!sender_realname'   => t('The real name of the sender (provided by RealName module).'),
        );
      }
      $tokens += array(
        '!sender_page'         => t('The user page of the sender (if the sender is visible).'),
        '!sender_has_contact_page' => t("The sender's contact setting: 1 = contact form enabled, 0 = disabled."),
        '!sender_contact_page' => t('The contact page of the sender.'),
        '!sender_uid'          => t('The ID of the sender (even if the sender is not visible!) (0 = %anonymous). ', array('%anonymous' => variable_get('anonymous', t('Anonymous')))),
        '!subs_type'           => t("The type of the subscription, like '!thread' or '!category'.", array('!thread' => t('thread'), '!category' => $tr('category'))),
        '!node_type'           => t("The type of the node, like '!forum' or '!story'.", array('!forum' => 'forum', '!story' => 'story')),
        '!revision_name'       => t('The name of the user who made the last change to the node.'),
        '!revision_log'        => t('The revision log entry of the node.'),
        '!nid'                 => t('The ID of the node.'),
        '!title'               => t('The title of the subscriptions item.'),
        '!teaser'              => t('An excerpt of the subscriptions item.'),
        '!body'                => t('The body of the subscriptions item.'),
      );
      if (isset($options['tokens'])) {
        $tokens += $options['tokens'];
      }

      $tokens += module_invoke_all('subscriptions_tokens_list', $mailkey, array('tokens' => $tokens));

      if ($mailkey != 'digest') {
        $tokens['!full_node']  =  t('The full node as it appears on the website (must be specifically enabled !here). ', array('!here' => l(t('here'), 'admin/config/subscriptions', array('fragment' => 'edit-subscriptions-generate-full-node'))));
      }
      $tokens += array(
        '!url'                 => t('The URL of the item.'),
        '!is_new'              => t('The type of notification: 1 = new item, 0 = otherwise.'),
        '!is_updated'          => t('The type of notification: 1 = updated (possibly new and already updated) item, 0 = otherwise.'),
        '!is_old'              => t('The type of notification: 1 = neither new nor updated item, 0 = otherwise.'),
        '!is_published'        => t('The publication state: 1 = published, 0 = unpublished.<br />(Unpublished nodes are sent to users with the %administer_nodes permission only.)', array('%administer_nodes' => $tr('administer nodes'))),
        '!has_files'           => t('The presence of attached files or img_assist images: 1 = files are available in !files, 0 = no files.'),
        '!files'               => t('The list of attached files, one per line, if any, otherwise empty.'),
        '!has_new_comments'    => t('The comments state: 1 = comments are available in !comments, 0 = no comments.'),
        '!comments'            => t('One or more comments if available, otherwise empty.') . '<br />',
      );
      if ($mailkey == 'node-nid' || $mailkey == 'digest') {
        $tokens['!comments'] = $tokens['!comments'] . t('The rendering of the comments is defined by the template below.');
      }
      else {
        $tokens['!comments'] = $tokens['!comments'] . t('The rendering of the comments is defined by the !link.', array(
                                                          '!link' => '<a href="../subscriptions_content_node-nid/' . check_plain(arg(4)) . '#edit-comment-body">' . t('comment templates') . '</a>'));
      }
  }
  return $tokens;
}

/**
 * Implements hook_mail_edit_text().
 *
 * Provide default template strings for mail_edit.
 *
 * @ingroup hooks
 */
function subscriptions_content_mail_edit_text($mailkey, $language) {
  if (!($return = module_invoke('subscriptions_mail', 'subscriptions_mail_text', $mailkey, $language))) {
    $return = module_invoke_all('subscriptions_mail_text', $mailkey, $language);
  }
  return $return;
}

/**
 * Implements hook_form_alter().
 *
 * Add the comment parts to the subscriptions_content_node-nid mail_edit page.
 *
 * @ingroup hooks
 * @ingroup form
 */
function subscriptions_content_form_mail_edit_trans_alter(&$form, &$form_state) {
  $mailkey = 'subscriptions_content_node-nid';
  if ($form['id']['#value'] == $mailkey) {
    $tr = 't';
    $langcode = $form['language']['#value'];

    $form['mail']['note'] = array(
      '#value' => '<div>' . t("Note: 'new' and 'update' notifications for %Pages subscriptions use the matching !content_type subscriptions template rather than this one, if allowed; this does not apply to 'comment'-only notifications.", array('%Pages' => t('Pages/Threads'), '!content_type' => t('content type'))) . '</div>',
      '#weight' => -1,
    );

    $comment_body = subscriptions_mail_template_load(SUBSCRIPTIONS_COMMENT_MAILKEY, $langcode, 'body', 'CITEM');
    $separator = subscriptions_mail_template_load(SUBSCRIPTIONS_COMMENT_MAILKEY, $langcode, 'subject', 'SEP');

    $form['mail']['comment_body'] = array(
      '#title'      => t('Comment body'),
      '#type'       => 'textarea',
      '#default_value'  => $comment_body,
      '#rows' => 7,
      '#description' => t('The body of each comment.'),
    );
    $placeholders = subscriptions_content_mail_edit_tokens_list('comments');
    // Display the user documentation of placeholders supported by this module mailkey
    $doc = "<dl>\n";
    foreach ($placeholders as $name => $description) {
      $doc .= '<dt>' . $name . '</dt>';
      $doc .= '<dd>' . $description . '</dd>';
    }
    $doc .= "</dl>\n";
    $form['mail']['comment_token_help'] = array(
      '#title' => $tr('Replacement patterns'),
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $form['mail']['comment_token_help']['help'] = array(
      '#value' => $doc,
    );
    $form['mail']['comment_separator'] = array(
      '#title'      => t('Comment separator'),
      '#type'       => 'textarea',
      '#default_value' => $separator,
      '#rows' => 2,
      '#description' => t('The separator between comments (if needed).'),
    );

    $form['op']['#submit'][] = 'subscriptions_content_form_mail_edit_trans_save';
    if (isset($form['delete'])) {
      $form['delete']['#submit'][] = 'subscriptions_content_form_mail_edit_trans_delete';
    }
  }
}

/**
 * Save handler for enhanced mail_edit page.
 */
function subscriptions_content_form_mail_edit_trans_save($form, &$form_state) {
  $form_state['values']['description'] = '';
  $form_state['values']['subject'] = $form_state['values']['comment_separator'];
  $form_state['values']['body'] = $form_state['values']['comment_body'];
  $form_state['values']['id'] .= '+comment';
  mail_edit_trans_save($form, $form_state);
}

/**
 * Delete handler for enhanced mail_edit page.
 */
function subscriptions_content_form_mail_edit_trans_delete($form, &$form_state) {
  db_delete('mail_edit')
    ->condition('id', $form_state['values']['id'] . '+comment')
    ->condition('language', $form_state['values']['language'])
    ->execute();
}

/**
 * Implements hook_node_type().
 *
 * Remove node type subscriptions when the underlying node type is removed.
 *
 * @ingroup hooks
 */
function subscriptions_content_node_type($op, $info) {
  switch ($op) {
    case 'delete':
      $type = $info->type;
      db_delete('subscriptions_queue')
        ->condition('module', 'node')
        ->condition('field', 'type')
        ->condition('value', $type)
        ->execute();
      db_delete('subscriptions')
        ->condition('module', 'node')
        ->condition('field', 'type')
        ->condition('value', $type)
        ->execute();
      foreach (array('blocked', 'unlisted') as $key) {
        $array = variable_get('subscriptions_' . $key . '_content_types', array());
        unset($array[$type]);
        variable_set('subscriptions_' . $key . '_content_types', $array);
      }
      break;
  }
}

/**
 * Implements hook_cron().
 *
 * Ensure that we're heavier than the taxonomy.module.
 *
 * @ingroup hooks
 */
function subscriptions_content_cron() {
  $result = db_query("SELECT name, weight FROM {system} WHERE name IN ('taxonomy', 'subscriptions_content') AND type = 'module'");
  foreach ($result as $module) {
    $weights[$module->name] = $module->weight;
  }
  if ($weights['subscriptions_content'] <= $weights['taxonomy']) {
    db_update('system')
      ->fields(array(
          'weight' => $weights['taxonomy'] + 1,
        ))
      ->condition('name', 'subscriptions_content')
      ->condition('type', 'module')
      ->execute();
  }
}

/**
 * Implements hook_disable().
 *
 * Remove our queue items.
 *
 * @ingroup hooks
 */
function subscriptions_content_disable() {
  db_delete('subscriptions_queue')
    ->condition('load_function', 'subscriptions_content_%', 'LIKE')
    ->execute();
}

